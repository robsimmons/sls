// Constant identifiers
cid: extensible.

// Permeability
perm: type. #type perm transparent.
pers: perm.
aff: perm.
lin: perm.
ord: perm.

// First-order terms (Spine-form LF)
exp: type. #type exp transparent.
spine: type. #type spine transparent.

knd: exp.
typ: exp.           // LF kind
nProp: exp.         // Negative SLS kind
pProp: perm -> exp. // Positive SLS kind (per/aff/lin/ord)
pi: string -> exp -> exp -> exp.
pii: string -> exp -> exp -> exp.
arrow: exp -> exp -> exp.
var: string -> nat -> spine -> exp.
con: cid -> spine -> exp.
lam: string -> exp -> exp.

nil: spine.
app: exp -> spine -> spine.
appi: exp -> spine -> spine.


// First-order classifiers
posProp: type. #type posProp transparent.
negProp: type. #type negProp transparent.

pAtom: perm -> cid -> spine -> posProp.
down: perm -> negProp -> posProp.
one: posProp.
fuse: posProp -> posProp -> posProp.
exists: string -> exp -> posProp -> posProp.
unif: exp -> exp -> posProp.

nAtom: cid -> spine -> negProp.
lax: posProp -> negProp.
lefti: posProp -> negProp -> negProp.
righti: posProp -> negProp -> negProp.
with: negProp -> negProp -> negProp.
all: string -> exp -> negProp -> negProp.
alli: string -> exp -> negProp -> negProp.



// Analyzing LF expressions
wExp: exp -> world.
wSpine: spine -> world.

headClass: {E: exp} exp -> rel @ wExp E.
headClass knd knd.
headClass typ typ.
headClass nProp nProp.
headClass (pProp Perm) (pProp Perm).
headClass (pii _ _ E) Eh <- headClass E Eh.
headClass (pi  _ _ E) Eh <- headClass E Eh.
headClass (arrow _ E) Eh <- headClass E Eh.

fv: {E: exp} string -> rel @ wExp E.
fvSpine: {Sp: spine} string -> rel @ wSpine Sp.

fv (pi X T E) Y <- fv T Y.
fv (pi X T E) Y <- fv E Y, X != Y.
fv (pii X T E) Y <- fv T Y.
fv (pii X T E) Y <- fv E Y, X != Y.
fv (arrow E1 E2) Y <- fv E1 Y.
fv (arrow E1 E2) Y <- fv E2 Y.
fv (var X _ Sp) X.
fv (var X _ Sp) Y <- fvSpine Sp Y.
fv (con _ Sp) Y <- fvSpine Sp Y.
fv (lam X E) Y <- fv E Y, X != Y.
#query freevars: fv + -.

fvSpine (app E Sp) Y <- fv E Y.
fvSpine (app E Sp) Y <- fvSpine Sp Y.
fvSpine (appi E Sp) Y <- fv E Y.
fvSpine (appi E Sp) Y <- fvSpine Sp Y.
#query freevarsSpine: fvSpine + -.



// Mode analysis
mode: type. #type mode transparent.
input: mode.
output: mode.

wMode: world.
givenMode: exp -> mode -> rel @ wMode.
varMode: string -> mode -> rel @ wMode.
givenMode E M, fv E X -> varMode X M.



// Analyzing types
wPos: posProp -> world.
wNeg: negProp -> world.

fvPos: {A: posProp} string -> rel @ wPos A.
fvNeg: {A: negProp} string -> rel @ wNeg A.

fvPos (pAtom _ _ Sp) Y <- fvSpine Sp Y.
fvPos (down _ A) Y <- fvNeg A Y.
fvPos (fuse A _) Y <- fvPos A Y.
fvPos (fuse _ A) Y <- fvPos A Y.
fvPos (exists X T A) Y <- fv T Y.
fvPos (exists X T A) Y <- fvPos A Y, X != Y.
fvPos (unif T S) Y <- fv T Y.
fvPos (unif T S) Y <- fv S Y.
#query freevarsPos: fvPos + -.

fvNeg (nAtom _ Sp) Y <- fvSpine Sp Y.
fvNeg (lax A) Y <- fvPos A Y.
fvNeg (lefti A _) Y <- fvPos A Y.
fvNeg (lefti _ A) Y <- fvNeg A Y.
fvNeg (righti A _) Y <- fvPos A Y.
fvNeg (righti _ A) Y <- fvNeg A Y.
fvNeg (with A _) Y <- fvNeg A Y.
fvNeg (with _ A) Y <- fvNeg A Y.
fvNeg (all X T A) Y <- fv T Y.
fvNeg (all X T A) Y <- fvNeg A Y, X != Y.
fvNeg (alli X T A) Y <- fv T Y.
fvNeg (alli X T A) Y <- fvNeg A Y, X != Y.
#query freevarsNeg: fvNeg + -.

headNeg: {A: negProp} negProp -> rel @ wNeg A.
headNeg (nAtom A Sp) (nAtom A Sp).
headNeg (lax A) (lax A).
headNeg A H -> headNeg (lefti _ A) H.
headNeg A H -> headNeg (righti _ A) H.
headNeg A H -> headNeg (with A _) H.
headNeg A H -> headNeg (with _ A) H.
headNeg A H -> headNeg (all _ _ A) H.
headNeg A H -> headNeg (alli _ _ A) H.
#query negHeads: headNeg + -.



// Storing the signature
wSignat: cid -> world.
signat: {C: cid} exp -> exp -> rel @ wSignat C.
rules: {R: cid} negProp -> rel @ wSignat R.
#query lookup: signat + - -.
#query lookupRule: rules + -.

classify: {C: cid} exp -> rel @ wSignat C.
classify C Eh <- signat C E _, headClass E Eh.
#query lookupClass: classify + -.



