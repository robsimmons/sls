// Constant identifiers
cid: extensible.

// Permeability
perm: type. #type perm transparent.
pers: perm.
aff: perm.
lin: perm.
ord: perm.

// First-order terms (Spine-form LF)
exp: type. #type exp transparent.
spine: type. #type spine transparent.

knd: exp.
typ: exp.           // LF kind
nProp: exp.         // Negative SLS kind
pProp: perm -> exp. // Positive SLS kind (per/aff/lin/ord)
pi: string -> exp -> exp -> exp.
pii: string -> exp -> exp -> exp.
arrow: exp -> exp -> exp.
var: string -> nat -> spine -> exp.
con: cid -> spine -> exp.
lam: string -> exp -> exp.

nil: spine.
app: exp -> spine -> spine.
appi: exp -> spine -> spine.


// First-order classifiers
posProp: type. #type posProp transparent.
negProp: type. #type negProp transparent.

pAtom: perm -> cid -> spine -> posProp.
down: perm -> negProp -> posProp.
one: posProp.
fuse: posProp -> posProp -> posProp.
exists: string -> exp -> posProp -> posProp.
unif: exp -> exp -> posProp.

nAtom: cid -> spine -> negProp.
lax: posProp -> negProp.
lefti: posProp -> negProp -> negProp.
righti: posProp -> negProp -> negProp.
with: negProp -> negProp -> negProp.
all: string -> exp -> negProp -> negProp.
alli: string -> exp -> negProp -> negProp.



// Analyzing LF expressions
wExp: exp -> world.

headClass: {E: exp} exp -> rel @ wExp E.
headClass knd knd.
headClass typ typ.
headClass nProp nProp.
headClass (pProp Perm) (pProp Perm).
headClass (pii _ _ E) Eh <- headClass E Eh.
headClass (pi  _ _ E) Eh <- headClass E Eh.
headClass (arrow _ E) Eh <- headClass E Eh.

// Storing the signature
wSignat: cid -> world.
signat: {C: cid} exp -> exp -> rel @ wSignat C.
rules: {R: cid} negProp -> rel @ wSignat R.
#query lookup: signat + - -.
#query lookupRule: rules + -.

classify: {C: cid} exp -> rel @ wSignat C.
classify C Eh <- signat C E _, headClass E Eh.
#query lookupClass: classify + -.
